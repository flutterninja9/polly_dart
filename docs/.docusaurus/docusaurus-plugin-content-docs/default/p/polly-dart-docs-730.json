{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Welcome to Polly Dart","href":"/polly_dart/docs/","docId":"intro","unlisted":false},{"type":"category","label":"Getting Started","items":[{"type":"link","label":"Installation","href":"/polly_dart/docs/getting-started/installation","docId":"getting-started/installation","unlisted":false},{"type":"link","label":"Quick Start","href":"/polly_dart/docs/getting-started/quick-start","docId":"getting-started/quick-start","unlisted":false},{"type":"link","label":"Basic Concepts","href":"/polly_dart/docs/getting-started/basic-concepts","docId":"getting-started/basic-concepts","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Resilience Strategies","items":[{"type":"link","label":"Resilience Strategies Overview","href":"/polly_dart/docs/strategies/overview","docId":"strategies/overview","unlisted":false},{"type":"link","label":"Retry Strategy","href":"/polly_dart/docs/strategies/retry","docId":"strategies/retry","unlisted":false},{"type":"link","label":"Circuit Breaker Strategy","href":"/polly_dart/docs/strategies/circuit-breaker","docId":"strategies/circuit-breaker","unlisted":false},{"type":"link","label":"Timeout Strategy","href":"/polly_dart/docs/strategies/timeout","docId":"strategies/timeout","unlisted":false},{"type":"link","label":"Fallback Strategy","href":"/polly_dart/docs/strategies/fallback","docId":"strategies/fallback","unlisted":false},{"type":"link","label":"Hedging Strategy","href":"/polly_dart/docs/strategies/hedging","docId":"strategies/hedging","unlisted":false},{"type":"link","label":"Rate Limiter Strategy","href":"/polly_dart/docs/strategies/rate-limiter","docId":"strategies/rate-limiter","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Advanced Topics","items":[{"type":"link","label":"Combining Strategies","href":"/polly_dart/docs/advanced/combining-strategies","docId":"advanced/combining-strategies","unlisted":false},{"type":"link","label":"Custom Strategies","href":"/polly_dart/docs/advanced/custom-strategies","docId":"advanced/custom-strategies","unlisted":false},{"type":"link","label":"Monitoring and Observability","href":"/polly_dart/docs/advanced/monitoring","docId":"advanced/monitoring","unlisted":false},{"type":"link","label":"Testing Resilience Strategies","href":"/polly_dart/docs/advanced/testing","docId":"advanced/testing","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"API Reference","items":[{"type":"link","label":"ResiliencePipeline","href":"/polly_dart/docs/api/resilience-pipeline","docId":"api/resilience-pipeline","unlisted":false},{"type":"link","label":"ResiliencePipelineBuilder","href":"/polly_dart/docs/api/resilience-pipeline-builder","docId":"api/resilience-pipeline-builder","unlisted":false},{"type":"link","label":"ResilienceContext","href":"/polly_dart/docs/api/resilience-context","docId":"api/resilience-context","unlisted":false},{"type":"link","label":"Outcome","href":"/polly_dart/docs/api/outcome","docId":"api/outcome","unlisted":false},{"type":"link","label":"RetryStrategy","href":"/polly_dart/docs/api/retry-strategy","docId":"api/retry-strategy","unlisted":false},{"type":"link","label":"CircuitBreakerStrategy","href":"/polly_dart/docs/api/circuit-breaker-strategy","docId":"api/circuit-breaker-strategy","unlisted":false},{"type":"link","label":"TimeoutStrategy","href":"/polly_dart/docs/api/timeout-strategy","docId":"api/timeout-strategy","unlisted":false},{"type":"link","label":"FallbackStrategy","href":"/polly_dart/docs/api/fallback-strategy","docId":"api/fallback-strategy","unlisted":false},{"type":"link","label":"HedgingStrategy","href":"/polly_dart/docs/api/hedging-strategy","docId":"api/hedging-strategy","unlisted":false},{"type":"link","label":"RateLimiterStrategy","href":"/polly_dart/docs/api/rate-limiter-strategy","docId":"api/rate-limiter-strategy","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Examples","items":[{"type":"link","label":"HTTP Client with Resilience","href":"/polly_dart/docs/examples/http-client","docId":"examples/http-client","unlisted":false}],"collapsed":true,"collapsible":true}]},"docs":{"advanced/combining-strategies":{"id":"advanced/combining-strategies","title":"Combining Strategies","description":"One of Polly Dart's most powerful features is the ability to combine multiple resilience strategies into a single pipeline. This creates layered defense mechanisms that work together to handle different types of failures and optimize performance.","sidebar":"tutorialSidebar"},"advanced/custom-strategies":{"id":"advanced/custom-strategies","title":"Custom Strategies","description":"While Polly Dart provides six comprehensive built-in strategies, you might need to create custom strategies for specific scenarios. This guide shows you how to build your own resilience strategies that integrate seamlessly with the Polly Dart pipeline.","sidebar":"tutorialSidebar"},"advanced/monitoring":{"id":"advanced/monitoring","title":"Monitoring and Observability","description":"Monitoring your resilience strategies is crucial for understanding system behavior, identifying bottlenecks, and optimizing performance. This guide covers comprehensive monitoring approaches for Polly Dart applications.","sidebar":"tutorialSidebar"},"advanced/testing":{"id":"advanced/testing","title":"Testing Resilience Strategies","description":"Testing resilience strategies is crucial for ensuring your applications behave correctly under failure conditions. This comprehensive guide covers testing approaches from unit tests to chaos engineering.","sidebar":"tutorialSidebar"},"api/circuit-breaker-strategy":{"id":"api/circuit-breaker-strategy","title":"CircuitBreakerStrategy","description":"The CircuitBreakerStrategy prevents cascading failures by monitoring failure rates and temporarily blocking calls when thresholds are exceeded.","sidebar":"tutorialSidebar"},"api/fallback-strategy":{"id":"api/fallback-strategy","title":"FallbackStrategy","description":"The FallbackStrategy provides alternative responses when operations fail, ensuring graceful degradation and improved user experience.","sidebar":"tutorialSidebar"},"api/hedging-strategy":{"id":"api/hedging-strategy","title":"HedgingStrategy","description":"The HedgingStrategy improves performance by executing multiple parallel attempts and returning the first successful result, reducing latency caused by slow responses.","sidebar":"tutorialSidebar"},"api/outcome":{"id":"api/outcome","title":"Outcome","description":"The Outcome class represents the result of a resilience pipeline execution, containing either a successful result or exception information.","sidebar":"tutorialSidebar"},"api/rate-limiter-strategy":{"id":"api/rate-limiter-strategy","title":"RateLimiterStrategy","description":"The RateLimiterStrategy controls the rate of operations to prevent system overload and ensure fair resource usage.","sidebar":"tutorialSidebar"},"api/resilience-context":{"id":"api/resilience-context","title":"ResilienceContext","description":"The ResilienceContext class provides contextual information and state management throughout the execution of a resilience pipeline.","sidebar":"tutorialSidebar"},"api/resilience-pipeline":{"id":"api/resilience-pipeline","title":"ResiliencePipeline","description":"The ResiliencePipeline class is the core execution engine that combines multiple resilience strategies into a cohesive resilience solution.","sidebar":"tutorialSidebar"},"api/resilience-pipeline-builder":{"id":"api/resilience-pipeline-builder","title":"ResiliencePipelineBuilder","description":"The ResiliencePipelineBuilder class provides a fluent API for constructing resilience pipelines with multiple strategies.","sidebar":"tutorialSidebar"},"api/retry-strategy":{"id":"api/retry-strategy","title":"RetryStrategy","description":"The RetryStrategy provides automatic retry functionality for transient failures with configurable backoff strategies.","sidebar":"tutorialSidebar"},"api/timeout-strategy":{"id":"api/timeout-strategy","title":"TimeoutStrategy","description":"The TimeoutStrategy cancels operations that exceed a specified time limit, preventing resource exhaustion and improving system responsiveness.","sidebar":"tutorialSidebar"},"examples/http-client":{"id":"examples/http-client","title":"HTTP Client with Resilience","description":"This example demonstrates how to build a robust HTTP client using Polly Dart resilience strategies. We'll create a client that handles network failures, service outages, and slow responses gracefully.","sidebar":"tutorialSidebar"},"getting-started/basic-concepts":{"id":"getting-started/basic-concepts","title":"Basic Concepts","description":"Understanding the fundamental concepts behind Polly Dart will help you build more effective resilience strategies and debug issues when they arise.","sidebar":"tutorialSidebar"},"getting-started/installation":{"id":"getting-started/installation","title":"Installation","description":"Get Polly Dart up and running in your Dart or Flutter project in just a few steps.","sidebar":"tutorialSidebar"},"getting-started/quick-start":{"id":"getting-started/quick-start","title":"Quick Start","description":"Learn the basics of Polly Dart with hands-on examples. In 5 minutes, you'll understand how to build resilient applications with minimal code changes.","sidebar":"tutorialSidebar"},"intro":{"id":"intro","title":"Welcome to Polly Dart","description":"Polly Dart is a comprehensive resilience and transient-fault-handling library for Dart applications. Inspired by the .NET Polly library, it provides developers with powerful tools to handle failures gracefully and build robust applications.","sidebar":"tutorialSidebar"},"strategies/circuit-breaker":{"id":"strategies/circuit-breaker","title":"Circuit Breaker Strategy","description":"The Circuit Breaker Strategy protects your application from cascading failures by monitoring the health of external dependencies and temporarily blocking calls when they're failing. Like an electrical circuit breaker, it \"opens\" to stop the flow when problems are detected.","sidebar":"tutorialSidebar"},"strategies/fallback":{"id":"strategies/fallback","title":"Fallback Strategy","description":"The Fallback Strategy provides alternative responses when primary operations fail, enabling graceful degradation instead of complete failure. It's your safety net for maintaining user experience even when services are unavailable.","sidebar":"tutorialSidebar"},"strategies/hedging":{"id":"strategies/hedging","title":"Hedging Strategy","description":"The Hedging Strategy launches multiple parallel operations against the same resource and returns the result from whichever completes first. This proactive approach reduces tail latency and improves response times when some requests may be slower than others.","sidebar":"tutorialSidebar"},"strategies/overview":{"id":"strategies/overview","title":"Resilience Strategies Overview","description":"Polly Dart provides six core resilience strategies that can be combined to build robust applications. Each strategy addresses specific failure scenarios and can be configured to match your application's needs.","sidebar":"tutorialSidebar"},"strategies/rate-limiter":{"id":"strategies/rate-limiter","title":"Rate Limiter Strategy","description":"The Rate Limiter Strategy controls the rate of execution to prevent overwhelming resources and ensure fair usage. It acts as a traffic control system, queuing or rejecting requests when limits are exceeded, protecting both your application and downstream services.","sidebar":"tutorialSidebar"},"strategies/retry":{"id":"strategies/retry","title":"Retry Strategy","description":"The Retry Strategy automatically retries failed operations, making your application more resilient to transient failures like network hiccups, temporary service unavailability, or resource contention.","sidebar":"tutorialSidebar"},"strategies/timeout":{"id":"strategies/timeout","title":"Timeout Strategy","description":"The Timeout Strategy prevents operations from running indefinitely by cancelling them after a specified duration. This is crucial for maintaining responsive applications and preventing resource exhaustion.","sidebar":"tutorialSidebar"}}}}